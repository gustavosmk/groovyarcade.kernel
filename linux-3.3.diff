--- a/drivers/gpu/drm/drm_crtc_helper.c
+++ b/drivers/gpu/drm/drm_crtc_helper.c
@@ -118,6 +118,8 @@ int drm_helper_probe_single_connector_modes(struct drm_connector *connector,
 		goto prune;
 	}
 
+	if (connector->c15khz)
+		goto prune;
 	count = (*connector_funcs->get_modes)(connector);
 	if (count == 0 && connector->status == connector_status_connected)
 		count = drm_add_modes_noedid(connector, 1024, 768);
--- a/drivers/gpu/drm/drm_edid.c
+++ b/drivers/gpu/drm/drm_edid.c
@@ -482,6 +482,28 @@ static void edid_fixup_preferred(struct drm_connector *connector,
 	preferred_mode->type |= DRM_MODE_TYPE_PREFERRED;
 }
 
+struct drm_display_mode *drm_mode_find_c15khz(struct drm_device *dev,
+                                          int hsize, int vsize, int fresh)
+{
+       int i;
+       struct drm_display_mode *ptr, *mode;
+
+       mode = NULL;
+       for (i = 0; i < drm_num_c15khz_modes; i++) {
+               ptr = &drm_c15khz_modes[i];
+               if (hsize == ptr->hdisplay &&
+                       vsize == ptr->vdisplay &&
+                       (fresh == 0 || 
+                        fresh == drm_mode_vrefresh(ptr))) {
+                       /* get the expected default mode */
+                       mode = drm_mode_duplicate(dev, ptr);
+                       break;
+               }
+       }
+       return mode;
+}
+EXPORT_SYMBOL(drm_mode_find_c15khz);
+
 struct drm_display_mode *drm_mode_find_dmt(struct drm_device *dev,
 					   int hsize, int vsize, int fresh)
 {
--- a/drivers/gpu/drm/drm_edid_modes.h
+++ b/drivers/gpu/drm/drm_edid_modes.h
@@ -27,6 +27,44 @@
 #include "drmP.h"
 #include "drm_edid.h"
 
+ /*
+ * Arcade modelines
+ *
+ */
+static struct drm_display_mode drm_c15khz_modes[] = {
+       /* 320x240@60.00 15.660 Khz */
+       { DRM_MODE("320x240", DRM_MODE_TYPE_DRIVER, 6640, 320, 336,
+                  368, 424, 0, 240, 242, 245, 261, 0,
+                  DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC) },
+       /* 640x480@60.00 15.750 Khz */
+       { DRM_MODE("640x480", DRM_MODE_TYPE_DRIVER, 13104, 640, 664,
+                  728, 832, 0, 480, 484, 490, 525, 0,
+                  DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC | 
+                       DRM_MODE_FLAG_INTERLACE) },
+       /* 720x480@59.95 15.7369 Khz */
+       { DRM_MODE("720x480", DRM_MODE_TYPE_DRIVER, 14856, 720, 752,
+                  824, 944, 0, 480, 484, 490, 525, 0,
+                  DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC | 
+                       DRM_MODE_FLAG_INTERLACE) },
+       /* 768x576 15.6250 Khz */
+       { DRM_MODE("768x576", DRM_MODE_TYPE_DRIVER, 15625, 768, 800,
+                  872, 1000, 0, 576, 582, 588, 625, 0,
+                  DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC | 
+                       DRM_MODE_FLAG_INTERLACE) },
+       /* 800x600@50.00 15.725 Khz */
+       { DRM_MODE("800x576", DRM_MODE_TYPE_DRIVER, 16354, 800, 832,
+                  912, 1040, 0, 576, 584, 590, 629, 0,
+                  DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC | 
+                       DRM_MODE_FLAG_INTERLACE) },
+       /* 1024@768@40.00 16.300 Khz */
+       { DRM_MODE("1024x768", DRM_MODE_TYPE_DRIVER, 21386, 1024, 1072,
+                  1168, 1312, 0, 768, 774, 780, 815, 0,
+                  DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC | 
+                       DRM_MODE_FLAG_INTERLACE) },
+};
+static const int drm_num_c15khz_modes =
+       sizeof(drm_c15khz_modes) / sizeof(struct drm_display_mode);
+
 /*
  * Autogenerated from the DMT spec.
  * This table is copied from xfree86/modes/xf86EdidModes.c.
--- a/drivers/gpu/drm/drm_modes.c
+++ b/drivers/gpu/drm/drm_modes.c
@@ -1001,6 +1001,7 @@ bool drm_mode_parse_command_line_for_connector(const char *mode_option,
 	bool interlace = false, margins = false, was_digit = false;
 	int i;
 	enum drm_connector_force force = DRM_FORCE_UNSPECIFIED;
+	int c15khz;
 
 #ifdef CONFIG_FB
 	if (!mode_option)
@@ -1089,6 +1090,9 @@ bool drm_mode_parse_command_line_for_connector(const char *mode_option,
 
 			force = DRM_FORCE_OFF;
 			break;
+		case 'c':
+			c15khz = 1;
+			break;
 		default:
 			goto done;
 		}
@@ -1134,6 +1138,8 @@ done:
 	mode->interlace = interlace;
 	mode->margins = margins;
 	mode->force = force;
+	mode->c15khz = c15khz ? true : false;
+	connector->c15khz = mode->c15khz;
 
 	return true;
 }
--- a/drivers/gpu/drm/drm_fb_helper.c
+++ b/drivers/gpu/drm/drm_fb_helper.c
@@ -1027,6 +1041,20 @@ static struct drm_display_mode *drm_pick_cmdline_mode(struct drm_fb_helper_conne
 	if (cmdline_mode->rb || cmdline_mode->margins)
 		goto create_mode;
 
+	if (cmdline_mode->c15khz) {
+		mode = drm_mode_find_c15khz(fb_helper_conn->connector->dev,
+			cmdline_mode->xres,
+			cmdline_mode->yres,
+			(cmdline_mode->refresh_specified) ?
+				cmdline_mode->refresh : 0);
+
+		if (mode) {
+			drm_mode_set_crtcinfo(mode, CRTC_INTERLACE_HALVE_V);
+			list_add(&mode->head, &fb_helper_conn->connector->modes);
+			return mode;
+		}
+	}
+
 	list_for_each_entry(mode, &fb_helper_conn->connector->modes, head) {
 		/* check width/height */
 		if (mode->hdisplay != cmdline_mode->xres ||
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -588,6 +588,9 @@ struct drm_connector {
 	int video_latency[2];	/* [0]: progressive, [1]: interlaced */
 	int audio_latency[2];
 	int null_edid_counter; /* needed to workaround some HW bugs where we get all 0s */
+
+	/* 15KHz output */
+	bool c15khz;
 };
 
 /**
@@ -996,6 +998,8 @@ int hdisplay, int vdisplay);
 
 extern int drm_edid_header_is_valid(const u8 *raw_edid);
 extern bool drm_edid_is_valid(struct edid *edid);
+struct drm_display_mode *drm_mode_find_c15khz(struct drm_device *dev,
+					      int hsize, int vsize, int fresh);
 struct drm_display_mode *drm_mode_find_dmt(struct drm_device *dev,
 					   int hsize, int vsize, int fresh);
 
--- a/include/drm/drmP.h
+++ b/include/drm/drmP.h
@@ -1012,6 +1012,7 @@ struct drm_fb_helper_cmdline_mode {
 	bool cvt;
 	bool margins;
 	enum drm_connector_force force;
+	bool c15khz;
 };
 
 
